use ai_sdk_provider::shared::provider_metadata::ProviderMetadata;
use serde::{Deserialize, Serialize};

/// Text output of a text generation.
///
/// This represents plain text content generated by the model.
///
/// # Example
///
/// ```
/// use ai_sdk_core::TextOutput;
///
/// let text = TextOutput::new("Hello, world!");
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TextOutput {
    /// Type discriminator (always "text").
    #[serde(rename = "type")]
    pub text_type: String,

    /// The text content.
    pub text: String,

    /// Additional provider-specific metadata.
    ///
    /// These are passed through to the provider from the AI SDK and enable
    /// provider-specific functionality that can be fully encapsulated in the provider.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<ProviderMetadata>,
}

impl TextOutput {
    /// Creates a new text output.
    ///
    /// # Arguments
    ///
    /// * `text` - The text content
    ///
    /// # Example
    ///
    /// ```
    /// use ai_sdk_core::TextOutput;
    ///
    /// let text = TextOutput::new("The weather is sunny today.");
    /// assert_eq!(text.text, "The weather is sunny today.");
    /// ```
    pub fn new(text: impl Into<String>) -> Self {
        Self {
            text_type: "text".to_string(),
            text: text.into(),
            provider_metadata: None,
        }
    }

    /// Sets the provider metadata for this text output.
    ///
    /// # Arguments
    ///
    /// * `metadata` - Provider-specific metadata
    ///
    /// # Example
    ///
    /// ```ignore
    /// use ai_sdk_core::TextOutput;
    ///
    /// let text = TextOutput::new("Hello")
    ///     .with_provider_metadata(metadata);
    /// ```
    pub fn with_provider_metadata(mut self, metadata: ProviderMetadata) -> Self {
        self.provider_metadata = Some(metadata);
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_text_output_new() {
        let text = TextOutput::new("Hello, world!");

        assert_eq!(text.text_type, "text");
        assert_eq!(text.text, "Hello, world!");
        assert!(text.provider_metadata.is_none());
    }

    #[test]
    fn test_text_output_with_provider_metadata() {
        let mut metadata = ProviderMetadata::new();
        let mut inner = HashMap::new();
        inner.insert("key".to_string(), serde_json::json!("value"));
        metadata.insert("provider".to_string(), inner);

        let text = TextOutput::new("Test")
            .with_provider_metadata(metadata.clone());

        assert_eq!(text.provider_metadata, Some(metadata));
    }

    #[test]
    fn test_text_output_serialization() {
        let text = TextOutput::new("Serialize me");

        let serialized = serde_json::to_value(&text).unwrap();

        assert_eq!(serialized["type"], "text");
        assert_eq!(serialized["text"], "Serialize me");
        assert!(serialized.get("providerMetadata").is_none());
    }

    #[test]
    fn test_text_output_deserialization() {
        let json = serde_json::json!({
            "type": "text",
            "text": "Deserialized text"
        });

        let text: TextOutput = serde_json::from_value(json).unwrap();

        assert_eq!(text.text_type, "text");
        assert_eq!(text.text, "Deserialized text");
        assert!(text.provider_metadata.is_none());
    }

    #[test]
    fn test_text_output_clone() {
        let text = TextOutput::new("Clone me");
        let cloned = text.clone();

        assert_eq!(text, cloned);
    }
}
